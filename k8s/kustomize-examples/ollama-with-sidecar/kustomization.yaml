apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

# Each of these YAML files contains a Deployment and a Service.
# The blue.yaml file is here just to demonstrate that the rest
# of this Kustomization can be precisely scoped to the ollama
# Deployment (and Service): the blue Deployment and Service
# shouldn't be affected by our kustomize transformers.
resources:
- ollama.yaml
- blue.yaml

buildMetadata:

# Add a label app.kubernetes.io/managed-by=kustomize-vX.Y.Z
- managedByLabel

# Add an annotation config.kubernetes.io/origin, indicating:
# - which file defined that resource;
# - if it comes from a git repository, which one, and which
#   ref (tag, branch...) it was.
- originAnnotations

# Add an annotation alpha.config.kubernetes.io/transformations
# indicating which patches and other transformers have changed
# each resource.
- transformerAnnotations

# Let's generate a ConfigMap with literal values.
# Note that this will actually add a suffix to the name of the
# ConfigMaps (e.g.: ollama-8bk8bd8m76) and it will update all
# references to the ConfigMap (e.g. in Deployment manifests)
# accordingly. The suffix is a hash of the ConfigMap contents,
# so that basically, if the ConfigMap is edited, any workload
# using that ConfigMap will automatically do a rolling update.
configMapGenerator:
- name: ollama
  literals:
  - "model=gemma3:270m"
  - "prompt=If you visit Paris, I suggest that you"
  - "queue=4"
  name: ollama

patches:
# The Deployment manifest in ollama.yaml doesn't specify
# resource requests and limits, so that it can run on any
# cluster (including resource-constrained local clusters
# like KiND or minikube). The example belows add CPU
# requests and limits using a strategic merge patch.
# The patch is inlined here, but it could also be put
# in a file and referenced with "path: xxxxxx.yaml".
- patch: |
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: ollama
    spec:
      template:
        spec:
          containers:
          - name: ollama
            resources:
              requests:
                cpu: 1
              limits:
                cpu: 2
# This will have the same effect, with one little detail:
# JSON patches cannot specify containers by name, so this
# assumes that the ollama container is the first one in
# the pod template (whereas the strategic merge patch can
# use "merge keys" and identify containers by their name).
#- target:
#    kind: Deployment
#    name: ollama
#  patch: |
#    - op: add
#      path: /spec/template/spec/containers/0/resources
#      value:
#        requests:
#          cpu: 1
#        limits:
#          cpu: 2

# A "component" is a bit like a "base", in the sense that
# it lets us define some reusable resources and behaviors.
# There is a key different, though:
# - a "base" will be evaluated in isolation: it will
#   generate+transform some resources, then these resources
#   will be included in the main Kustomization;
# - a "component" has access to all the resources that
#   have been generated by the main Kustomization, which
#   means that it can transform them (with patches etc).
components:
- add-haproxy-sidecar
